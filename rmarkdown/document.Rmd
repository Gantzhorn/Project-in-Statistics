---
title: "Project In Statistics"
author: "Anders Gantzhorn Kristensen"
date: "2023-04-29"
output: html_document
---

```{r setup, include=FALSE, warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(momentuHMM)
library(ggmap)
library(plotly)
library(gridExtra)
library(geodata)
library(plot3D)
library(grid)
library(ggExtra)
library(leaflet)
library(rgdal)
library(xtable)
library(sf)
library(mapview)
library(ggthemes)
library(raster)

theme_set(theme_bw())
proj_palette <- c("#E69F00", "#56B4E9", "#009E73",
                         "#F0E442", "#0072B2", "#D55E00",
                         "#CC79A7")
#plotPath = "/home/anders/Desktop/Skole/Blok 4 - 2023/Project in Statistics/Project-in-Statistics/latex/figures"
```

# Analysis of eagle data

First we load the data and calculate the vertical_steps by looking at the changing in altitude to the last position

```{r, include=FALSE, message = FALSE}
eagleDataOriginal <- readr::read_csv("Eagle_data_with_GPS_positions.csv")
eagleData <- eagleDataOriginal
eagleData %>% mutate(Segment_ID = factor(Segment_ID))
eagleData <- eagleData %>% group_by(Segment_ID) %>%
    mutate(vertical_steps = Altitude - lag(Altitude, default = first(Altitude))) %>% 
    rename(horizontal_steps = Step_length) %>% 
    slice(2:n()) %>% ungroup()
```

# Plot the tracks of the birds
```{r, echo = FALSE}
# allBirdsMap <- ggmap::get_stamenmap(bbox = c(left = min(eagleData$Longitude),
#                               right = -73,
#                               bottom = min(eagleData$Latitude),
#                               top = 43),
#                               maptype = "terrain-background",
#                               crop = FALSE,
#                               zoom = 9)
# USMAP <- ggmap::get_stamenmap(bbox = c(left = -125, right = -67, bottom = 24, top = 49),
#                               maptype = "terrain-background",
#                               crop = FALSE,
#                               zoom = 6)
# 
# allBirdsMapZoomed <- ggmap(USMAP) + theme(axis.title = element_blank(), 
#           axis.text  = element_blank(),
#           axis.ticks = element_blank()) +
#   geom_rect(xmin = min(eagleData$Longitude), xmax =  -73, ymin =  min(eagleData$Latitude), ymax =  43,
#             fill = NA, color = "firebrick", linewidth = 0.6)
# rm(USMAP)
# allBirdsAndInset <- ggmap(allBirdsMap) +
#   geom_point(data = eagleData, aes(x = Longitude, y = Latitude, group = Segment_ID),
#              col = "black", size = 0.0001) +
#   theme(plot.title = element_text(size = 14, face = "bold"),
#         axis.text = element_text(size = 12),
#         axis.title = element_text(size = 14, face = "bold")) +
#   ggmap::inset(ggplotGrob(allBirdsMapZoomed), xmin = -76, xmax = -73, ymin = 38, ymax = 41.4) +
#   labs(x = "Longitude (°)", y = "Latitude (°)")
# allBirdsAndInset
# ggsave(filename = "allBirdTracks.jpeg", plot = allBirdsAndInset, path = plotPath, width = 12.26, height = 9.77)
```

# Simple summary statistics

```{r, include = FALSE}
# eagleData %>% ungroup() %>% select(Longitude, Latitude, horizontal_steps, vertical_steps) %>% summary() %>% xtable(include.rownames = FALSE)
# 
# horizontal_marginal <- eagleData %>% 
#   ggplot(aes(x = horizontal_steps)) +
#   geom_density(color = "black", fill = proj_palette[1], linewidth = 0.5) +
#   labs(y = NULL, x = "Horizontal Step Length") +
#   theme(
#     axis.text = element_text(size = 12),
#     axis.title = element_text(size = 12, face = "bold"),
#     panel.background = element_blank(),
#     panel.grid.major = element_blank(),
#     panel.grid.minor = element_blank()
#   ) +  scale_x_log10()
# 
# vertical_marginal <- eagleData %>% 
#   ggplot(aes(x = vertical_steps)) +
#   geom_density(color = "black", fill = proj_palette[2], linewidth = 0.5) +
#   labs(y = NULL, x = "Vertical Step Length") +
#   theme(
#     axis.text = element_text(size = 12),
#     axis.title = element_text(size = 12, face = "bold"),
#     panel.background = element_blank(),
#     panel.grid.major = element_blank(),
#     panel.grid.minor = element_blank()
#   )
# 
# verticalHorizontal_joint <- ggplot(eagleData, aes(x = horizontal_steps, y = vertical_steps)) +
#   stat_density_2d(aes(fill = ..level..), geom = "polygon", colour = "white") +
#   scale_fill_gradientn(colors = c(proj_palette[1], proj_palette[5])) +
#   labs(x = "Horizontal Steplength", y = "Vertical Steplength", fill = "Density") + scale_x_log10() + 
#     theme(
#     axis.text = element_text(size = 12),
#     axis.title = element_text(size = 12, face = "bold"),
#     panel.background = element_blank(),
#     panel.grid.major = element_blank(),
#     panel.grid.minor = element_blank()
#   ) +
#   guides(fill = guide_colorbar(title.position = "top", title.theme = element_text(face = "bold")))
#   
# 
# marginalAndJointDistributions <- grid.arrange(verticalHorizontal_joint, horizontal_marginal, vertical_marginal,
#              layout_matrix = matrix(c(2, 2, 2, 2, 3, 3, 3, 3, NA, 1, 1 ,1, 1, 1, 1, NA), nrow = 2,byrow = TRUE))
# 
# ggsave(filename = "horizontalAndVerticalDensities.jpeg", plot = marginalAndJointDistributions, path = plotPath)
```
## Estimation using Weibull- and Gamma distributions
### Weibull distribution
First assume that Step_length is Weibull distributed. The MLE of $k$ is the solution to
$$
0 = \frac{\sum_{i = 1}^N X_i^k\log(X_i)}{\sum_{i = 1}^N X_i^k} - \frac{1}{k} - \frac{1}{N}\sum_{i = 1}^N \log(X_i)
$$
whereas the MLE of $\lambda$ given $k$ is:
$$
\hat{\lambda} = \left(\frac{1}{N} \sum_{i = 1}^N X_i^k\right)^{\frac{1}{k}}
$$
Thus we can calculate the MLE assuming step-length has a Weibull distribtion
```{r message = FALSE}
k_hat <- uniroot(function(k) {sum(eagleData$horizontal_steps^k * log(eagleData$horizontal_steps)) / sum(eagleData$horizontal_steps^k) - 1/k - mean(log(eagleData$horizontal_steps))},
                    c(0.1, 10))$root
lambda_hat <- (mean(eagleData$horizontal_steps^k_hat))^(1/k_hat)
```

### Fitting the vertical steps to a normal distribution
The MLE of the mean in the normal distribution is:
$$
\hat{\mu} = \frac{1}{N}\sum_{i = 1}^N X_i
$$
Whereas the variance is:
$$
\hat{\sigma}^2 = \frac{1}{N}\sum_{i = 1}^N \left(X_i-\hat{\mu}\right)^2
$$
Which we implement.
```{r message = FALSE}
mu_hat <- mean(eagleData$vertical_steps)
sigmasq_hat <- var(eagleData$vertical_steps)
```


```{r message = FALSE}
prepEagleData <- momentuHMM::prepData(data = data.frame(ID = eagleData$Segment_ID,
                                       vertical_steps = eagleData$vertical_steps,
                                       horizontal_steps = eagleData$horizontal_steps),
                                       coordNames = NULL)
```
We also need the number of observations per animal for the validation process later.
```{r message = FALSE}
obsPerAnimal <- as.list(as.numeric(table(prepEagleData$ID))) 
```

## Model fitting

We fit the model using the parameters from above and decode the states
```{r message = FALSE}
N <- 3 
# Initial values for weibull distributions of horizontal distances
k0 <- rep(k_hat, times = N)
lambda0 <- rep(lambda_hat, times = N)

# Initial values for normal distributions for vertical distances
mu0 <- rep(mu_hat, times = N)
sigma0 <- rep(sigmasq_hat, times = N)
eagleFit1 <- momentuHMM::fitHMM(prepEagleData,
                   nbStates = N,
                   dist = list(horizontal_steps = "weibull",
                          vertical_steps = "norm"),
                   Par0 = list(horizontal_steps = c(k0, lambda0),
                          vertical_steps = c(mu0, sigma0))
)

decodedStatesFit1 <- viterbi(m = eagleFit1)

```
Instead of using the generic plot method, we can use our own

```{r message = FALSE}
numberAfterState <- decodedStatesFit1 %>% tibble(stateNum=.) %>% group_by(stateNum) %>% count() %>% ungroup() %>% mutate(prop = n/sum(n))
```

Also get the mean and variance of each of the states
```{r message = FALSE}
# Set the parameters for the Weibull distributions
# shape_params <- eagleFit1$mle$horizontal_steps[1,]
# scale_params <- eagleFit1$mle$horizontal_steps[2,]
# 
# matrix(c(scale_params*gamma(1+1/shape_params),eagleFit1$mle$vertical_steps[1,]), nrow = 2, byrow = T) # mean
# xtable(matrix(c(scale_params*gamma(1+1/shape_params),
#                 sqrt(scale_params^2*(gamma(1+2/shape_params)-gamma(1+1/shape_params)^2)),
#                 eagleFit1$mle$vertical_steps[1,],
#                 eagleFit1$mle$vertical_steps[2,]), nrow = 4, byrow = T),
#                 )
```

## Make the weighted density plot

### For horizontal steps

```{r message = FALSE}
# Set the number of observations for each distribution

# num_observations <- c(numberAfterState$n[numberAfterState$stateNum == 1], 
#                       numberAfterState$n[numberAfterState$stateNum == 2], 
#                       numberAfterState$n[numberAfterState$stateNum == 3])
# 
# # Generate the x values
# x <- density(eagleData$horizontal_steps)$x
# 
# # Calculate the density values for each distribution
# pdf_values <- sapply(1:N, function(i) {
#   density <- dweibull(x, shape = shape_params[i], scale = scale_params[i])
#   density <- density * numberAfterState$prop[numberAfterState$stateNum == i]
#   density
# })
# 
# 
# 
# # Create a data frame for the density values
# df <- data.frame(x = rep(x, (N+1)),
#                  density = as.vector(cbind(pdf_values, rowSums(pdf_values))),
#                  state = factor(rep(c(1:N, "Total"), each = length(x))))
# 
# # Plot the density functions using ggplot2
# xCombinedDensity <- ggplot() +
#   geom_histogram(data = eagleData, aes(x = horizontal_steps, after_stat(density)), fill = "steelblue", col = "black", bins = 75, linewidth = 0.5, alpha = .2) +
#   geom_line(data = filter(df, state != "Total"), aes(x = x, y = density, color = state),
#             lwd = 2, alpha = 1.5) +
#   geom_line(data = filter(df, state == "Total"), aes(x = x, y = density),
#           lwd = 1, alpha = 1.5, linetype = "dashed") +
#   xlab("Horizontal steps") +
#   ylab("Density") +
#   scale_color_manual(values = proj_palette,
#                      labels = c("Gliding", "Soaring", "Perching")) +
#   theme(text = element_text(size = 14, face = "bold"),
#         legend.position = "None") +
#   coord_cartesian(xlim = c(0, 2000))
# 
# ggsave(filename = "horizontalStepsCombinedDistributionInitialFit.jpeg",
#        plot = xCombinedDensity, path = plotPath, width = 6, height = 4, units = "in")
# 
# ##------------------------------------------------------------------------------------------------------#
# 
# xCombinedDensityZoom <- ggplot() +
#   geom_histogram(data = eagleData, aes(x = horizontal_steps, after_stat(density)), fill = "steelblue", col = "black", bins = 1000, linewidth = 0.5, alpha = .2) +
#   geom_line(data = filter(df, state != "Total"), aes(x = x, y = density, color = state),
#             lwd = 2, alpha = 1.5) +
#   geom_line(data = filter(df, state == "Total"), aes(x = x, y = density),
#           lwd = 1, alpha = 1.5, linetype = "dashed") +
#   xlab("Horizontal steps") +
#   ylab("Density") +
#   scale_color_manual(values = proj_palette,
#                      labels = c("Gliding", "Soaring", "Perching")) +
#   theme(text = element_text(size = 14, face = "bold"),
#         legend.position = "None") +
#   coord_cartesian(xlim = c(0, 100))
# 
# ggsave(filename = "horizontalStepsCombinedDistributionInitialFitZoom.jpeg",
#        plot = xCombinedDensityZoom, path = plotPath, width = 6, height = 4, units = "in")

```

### For vertical steps 
```{r message = FALSE}
# # Set the parameters for the Weibull distributions
# mean_params <- eagleFit1$mle$vertical_steps[1,]
# sd_params <- (eagleFit1$mle$vertical_steps[2,])
# 
# # Generate the x values
# x <- density(eagleData$vertical_steps)$x
# 
# # Calculate the density values for each distribution
# pdf_values <- sapply(1:N, function(i) {
#   density <- dnorm(x, mean = mean_params[i], sd = sd_params[i])
#   density <- density * numberAfterState$prop[numberAfterState$stateNum == i]
#   density
# })


# 
# # Create a data frame for the density values
# df <- data.frame(x = rep(x, (N+1)),
#                  density = as.vector(cbind(pdf_values, rowSums(pdf_values))),
#                  state = factor(rep(c(1:N, "Total"), each = length(x))))
# 
# # Plot the density functions using ggplot2
# yCombinedDensity <- ggplot() +
#   geom_histogram(data = eagleData, aes(x = vertical_steps, after_stat(density)), fill = "steelblue", col = "black", bins = 200, linewidth = 0.5, alpha = .2) +
#   geom_line(data = filter(df, state != "Total"), aes(x = x, y = density, color = state),
#             lwd = 2, alpha = 1.5) +
#   geom_line(data = filter(df, state == "Total"), aes(x = x, y = density),
#             lwd = 1, alpha = 1.5, linetype = "dashed") +
#   xlab("Vertical steps") +
#   ylab("") +
#   scale_color_manual(values = proj_palette,
#                     labels = c("Gliding", "Soaring", "Perching")) +
#   theme(text = element_text(size = 12, face = "bold"),
#         legend.title = element_blank()) +
#   coord_cartesian(xlim = c(-500, 500))
# 
# ggsave(filename = "verticalStepsCombinedDistributionInitialFit.jpeg",
#        plot = yCombinedDensity, path = plotPath, width = 6, height = 4, units = "in")
```

Add decoded states to the dataset
```{r message = FALSE}
eagleData <- tibble(eagleData, decodedstates = decodedStatesFit1)
eagleData <- eagleData %>% mutate(decodedstates = factor(decodedstates))
```
And plot the data stratified to the states
```{r message = FALSE}
# ggplot(eagleData, aes(x = horizontal_steps, y = vertical_steps, col = decodedstates)) + 
#   geom_point(alpha = 0.4) +
#   scale_color_manual(values = proj_palette,
#                      labels = c("Gliding", "Soaring", "Perching"),
#                      guide = guide_legend(override.aes = list(alpha = 1))) + 
#   scale_x_log10() + 
#   xlab("Horizontal steps") +
#   ylab("Vertical steps") + 
#   facet_wrap(~ decodedstates, ncol = 3, scale = "free_x") + 
#   theme(text = element_text(size = 14, face = "bold"),
#         legend.title = element_blank(),
#         strip.text = element_text(size = 0),
#         strip.background = element_blank())

```

```{r message = FALSE}
# Find interesting birds:
# VaryingSegmentID <- eagleData %>% 
#   group_by(Segment_ID, decodedstates) %>%
#   summarise(n = n(), .groups = "drop") %>%
#   group_by(Segment_ID) %>%
#   mutate(prop = n/sum(n)) %>%
#   ungroup() %>%
#   dplyr::select(-n) %>%
#   pivot_wider(names_from = "decodedstates", values_from = "prop") %>%
#   replace_na(list(`1` = 0, `2` = 0, `3` = 0)) %>% filter(`1`>0.2 & `2`>0.2 & `3`>0.2) %>% .$Segment_ID

```


```{r message = FALSE}
# AltitudeFourBirds <- eagleData %>%
#   filter(Segment_ID %in% c(48, 499, 205, 445)) %>%
#   group_by(Segment_ID) %>%
#   mutate(obsNum = row_number()) %>%
#   ggplot(aes(x = obsNum, y = Altitude)) +
#   geom_line(linewidth = 0.5) +
#   geom_point(aes(col = decodedstates)) +
#   facet_wrap(~Segment_ID, scales = "free") +
#   scale_color_manual(values = proj_palette,
#                      labels = c("Gliding", "Soaring", "Perching"),
#                      guide = guide_legend(override.aes = list(alpha = 1))) +
#     labs(x = "Time since start of segment (minutes)", y = "Altitude (MAMSL)", color = "Decoded state") +
#     theme(text = element_text(face = "bold"), 
#           strip.text = element_text(face = "bold", size = 14),
#           axis.title = element_text(face = "bold", size = 14),
#           legend.title = element_text(face = "bold", size = 14),
#           legend.text = element_text(face = "bold", size = 12)
#     )
# 
# ggsave(filename = "AltitudeFourBirds.jpeg",
#        plot = AltitudeFourBirds, path = plotPath, width = 10, height = 6)
# 
# 
# Altitudebird539 <- eagleData %>%
#     filter(Segment_ID == 539) %>%
#     group_by(Segment_ID) %>%
#     mutate(obsNum = row_number()) %>%
#     ggplot(aes(x = obsNum, y = Altitude)) +
#     geom_line(linewidth = 0.25) +
#     geom_point(aes(col = decodedstates), size = 2.5) +
#     scale_color_manual(values = proj_palette,
#                        labels = c("Gliding", "Soaring", "Perching"),
#                        guide = guide_legend(override.aes = list(alpha = 1))) +
#     labs(x = "Time since start of segment (minutes)", y = "Altitude (MAMSL)", color = "Decoded state") +
#     theme(text = element_text(face = "bold"), 
#           strip.text = element_text(face = "bold", size = 16),
#           axis.title = element_text(face = "bold", size = 14),
#           legend.title = element_text(face = "bold", size = 14),
#           legend.text = element_text(face = "bold", size = 12)
#     ) + theme(legend.position="none")
# 
# 
# 
# ggsave(filename = "Altitudebird539.jpeg",
#        plot = Altitudebird539, path = plotPath, width = 10, height = 6)

```

## Assess the fitted model
Look at simulations from the model and whether they show similar patterns as the observed data. First we simulate from the model

```{r message = FALSE, include = FALSE}
# eagleSim <- momentuHMM::simData(nbAnimals = max(as.numeric(levels(prepEagleData$ID))),
#                                 nbStates = N,
#                                 model = eagleFit1,
#                                 obsPerAnimal = obsPerAnimal)
```

Then we compare the densities qualitatively

```{r message = FALSE}
# bind_rows(eagleSim, prepEagleData) %>%
#     mutate(Data = rep(c("Sim", "Obs"), each = nrow(eagleSim))) %>%
#   pivot_longer(cols = -c(ID, Data), names_to = "Movement_type", values_to = "Move") %>% 
#   ggplot(aes(x = Move, fill = Data)) + geom_density() +
#   scale_fill_manual(values = proj_palette) + facet_wrap(~Movement_type, ncol = 1, scale = "free")

# ggplot() + 
#   geom_histogram(data = eagleData, aes(x = horizontal_steps, y = ..density..), 
#                  fill = "steelblue", col = "black", alpha = .1, bins = 125) +
#   geom_density(data = eagleSim, aes(x = horizontal_steps), col = proj_palette[1], linewidth = 2) +
#   coord_cartesian(xlim = c(0, 2000)) + xlab("Horizontal steps") +
#     ylab("Density") +theme(text = element_text(size = 12, face = "bold"))
# 
# 
# ggplot() + 
#   geom_histogram(data = eagleData, aes(x = vertical_steps, y = ..density..), 
#                  fill = "steelblue", col = "black", alpha = .1, bins = 200) +
#   geom_density(data = eagleSim, aes(x = vertical_steps), col = proj_palette[2], linewidth = 2) +
#   coord_cartesian(xlim = c(-500, 500)) + xlab("Vertical steps") +
#     ylab("") +theme(text = element_text(size = 12, face = "bold"))

```

Now we compute the pseudoresiduals

```{r message = FALSE}
# pseudoReseagleFit1 <- momentuHMM::pseudoRes(eagleFit1)
# pseudoResTibble <- tibble(horizontal_stepsRes = pseudoReseagleFit1[[1]],
#                           vertical_stepsRes = pseudoReseagleFit1[[2]]
#                           ) %>% mutate(time = row_number())
```

```{r message = FALSE}
# QQ-plot of residuals
# horizontal_stepsQQRes <-  pseudoResTibble %>% ggplot(aes(sample = horizontal_stepsRes)) + 
#   geom_qq(alpha = .2) +
#   geom_abline(intercept = 0, slope = 1, color = "firebrick", linewidth = 1.5) +
#   labs(x = "Theoretical quantile (Horizontal steps)", y = "Sample quantile", color = "Decoded state") +
#     theme(text = element_text(face = "bold"), 
#           strip.text = element_text(face = "bold", size = 16),
#           axis.title = element_text(face = "bold", size = 14),
#           legend.title = element_text(face = "bold", size = 14),
#           legend.text = element_text(face = "bold", size = 12))
# 
# ggsave(filename = "horizontal_stepsQQRes.jpeg",
#        plot = horizontal_stepsQQRes, path = plotPath, width = 6, height = 4, units = "in")
# 
# vertical_stepsQQRes <- pseudoResTibble %>% ggplot(aes(sample = vertical_stepsRes)) + 
#   geom_qq(alpha = .2) +
#   geom_abline(intercept = 0, slope = 1, color = "firebrick", linewidth = 1.5) +
#   labs(x = "Theoretical quantile (Vertical steps)", y = "", color = "Decoded state") +
#     theme(text = element_text(face = "bold"), 
#           strip.text = element_text(face = "bold", size = 16),
#           axis.title = element_text(face = "bold", size = 14),
#           legend.title = element_text(face = "bold", size = 14),
#           legend.text = element_text(face = "bold", size = 12))
# 
# ggsave(filename = "vertical_stepsQQRes.jpeg",
#        plot = vertical_stepsQQRes, path = plotPath, width = 6, height = 4, units = "in")
```

```{r}
# Quantile calculation
quantilePoints <- c(0.025, 0.25, 0.5, 0.75, 0.975)

xtable(matrix(c(qnorm(p = quantilePoints),
         quantile(pseudoResTibble$horizontal_stepsRes, probs = quantilePoints),
                  quantile(pseudoResTibble$vertical_stepsRes, probs = quantilePoints)),
       ncol = length(quantilePoints), byrow = T))


```


```{r message = FALSE}
# Make autocorrelation plots
# acf_vals <- acf(pseudoResTibble$vertical_stepsRes[is.finite(pseudoResTibble$vertical_stepsRes)], plot = FALSE)
# acftib <- tibble(ACF = acf_vals$acf, lag = acf_vals$lag)
# acfVerticalPseudoResiduals <- ggplot(acftib[-1,], aes(x = lag, y = ACF)) +
#   geom_hline(yintercept = 0, color = "black", size = 1) +
#   geom_hline(yintercept = c(0.025, -0.025), linetype = "dashed",
#              color = proj_palette[3], linewidth = 1.5) +
#   geom_segment(aes(xend = lag, yend = 0), color = "black", size = 1) +
#   xlab("Lag (Vertical pseudoresiduals)") +
#   ylab("") +
#   theme(plot.title = element_text(face = "bold"), 
#         axis.title = element_text(face = "bold"))
# 
# acf_vals1 <-  acf(pseudoResTibble$horizontal_stepsRes[is.finite(pseudoResTibble$horizontal_stepsRes)], plot = FALSE)
# acftib1 <- tibble(ACF = acf_vals1$acf, lag = acf_vals1$lag)
# acfHorizontalPseudoResiduals <- ggplot(acftib1[-1,], aes(x = lag, y = ACF)) +
#   geom_hline(yintercept = 0, color = "black", size = 1) +
#   geom_hline(yintercept = c(0.025, -0.025), linetype = "dashed",
#              color = proj_palette[3], linewidth = 1.5) +
#   geom_segment(aes(xend = lag, yend = 0), color = "black", size = 1) +
#   xlab("Lag (Horizontal pseudoresiduals)") +
#   ylab("Autocorrelation") +
#   theme(plot.title = element_text(face = "bold"), 
#         axis.title = element_text(face = "bold"))
# 
# ggsave(filename = "acfVerticalPseudoResiduals.jpeg", plot = acfVerticalPseudoResiduals,
#        path = plotPath, height = 4, width = 6, units = "in")
# 
# ggsave(filename = "acfHorizontalPseudoResiduals.jpeg", plot = acfHorizontalPseudoResiduals,
#        path = plotPath, height = 4, width = 6, units = "in")
```

## Plot a few individual birds
### Using mapview
```{r message = FALSE}
 # Find segment with the most observations:
# favourite_bird <- eagleData %>% group_by(Segment_ID) %>% summarise(n = n()) %>% ungroup() %>% 
#   slice_max(n) %>% .$Segment_ID
# 
# 
# favourite_birdTibble <- eagleData %>% filter(Segment_ID == 539)
# favourite_birdTibble <- favourite_birdTibble %>% 
#   mutate(decodedstates = recode(decodedstates,
#                                 `1` = "Gliding",
#                                 `2` = "Soaring",
#                                 `3` = "Perching"))
# 
# proj_palette1 <- proj_palette[1:3]
# names(proj_palette1) <- unique(favourite_birdTibble$decodedstates)
# 
# # Create a color palette function
# colorPalette <- colorFactor(proj_palette1, favourite_birdTibble$decodedstates)
# 
# # Create the map
# leaflet_map <-  leaflet(favourite_birdTibble) %>%
#   addProviderTiles(providers$Esri.WorldImagery) %>%
#   addPolylines(lng = ~Longitude, lat = ~Latitude, color = "black") %>%
#   addCircleMarkers(lng = ~Longitude, lat = ~Latitude, radius = 5,
#                    color = ~colorPalette(decodedstates),
#                    fillColor = ~colorPalette(decodedstates),
#                    fillOpacity = 1,
#                    popup = ~decodedstates) %>%
#   addLegend("topleft", colors = proj_palette1,
#             title = "<b>Decoded State",
#             labels = paste("<b>", names(proj_palette1), "</b>"),
#             opacity = 1) %>% 
#   addScaleBar(position = "bottomright",
#               options = scaleBarOptions(metric = TRUE, imperial = FALSE, maxWidth = 200))

```
### Using ggmap

```{r}
# favoriteBirdMap <- ggmap::get_stamenmap(bbox = c(left = min(favourite_birdTibble$Longitude),
#                               right = max(favourite_birdTibble$Longitude),
#                               bottom = min(favourite_birdTibble$Latitude),
#                               top = max(favourite_birdTibble$Latitude)),
#                               maptype = "terrain",
#                               crop = FALSE,
#                               zoom = 11)
# 
# favoriteBirdMapAndTracks <- ggmap(favoriteBirdMap)+
#   geom_line(data = favourite_birdTibble, aes(x = Longitude, y = Latitude),
#             lwd = 0.1, col = "black") + 
#   geom_point(data = favourite_birdTibble, aes(x = Longitude, y = Latitude, col = decodedstates)) +
#   scale_color_manual(values = proj_palette) +
#   labs(title = "Segment 48 path",
#        x = "Longitude",
#        y = "Latitude") +
#   theme(plot.title = element_text(size = 14, face = "bold"),
#         axis.text = element_text(size = 12),
#         axis.title = element_text(size = 12),
#         legend.title = element_text(size = 12, face = "bold"),
#         legend.text = element_text(size = 10),
#         legend.position = "bottom")
# favoriteBirdMapAndTracks
```

# Investigate consequences of the correlation between the states

```{r}
obsPerAnimal <- as.numeric(table(prepEagleData$ID))
simNewEagles <- function(obsPerAnimal){
statesForSim <- rep(0, nrow(eagleFit1$data))
k <- 0
for (i in seq_along(obsPerAnimal)){
  statesForSim[k+1] <- sample.int(N, 1, prob = eagleFit1$mle$delta[1,])
  for(j in 2:obsPerAnimal[i]){
    statesForSim[j+k] <- sample.int(N, 1, prob = eagleFit1$mle$gamma[statesForSim[j+k-1], ])
  }
  k <- obsPerAnimal[i]+k
}
return(statesForSim)
}
weibullParameters <- matrix(c(eagleFit1$mle[[1]][1, ],
                              eagleFit1$mle[[1]][2, ]), ncol = N, byrow = TRUE)
normalParameters <- matrix(c(eagleFit1$mle[[2]][1, ],
                             eagleFit1$mle[[2]][2, ]), ncol = N, byrow = TRUE)

```

```{r}
# Fit similar data

statesForSim <- simNewEagles(obsPerAnimal)
covMatEagle <- matrix(c(1, 0.9,
                        0.9, 1), ncol = 2,
                      byrow = TRUE)


bivariateNormEagle = MASS::mvrnorm(n=nrow(eagleFit1$data), mu=c(0, 0),
                                   Sigma=covMatEagle, empirical=TRUE)
X = bivariateNormEagle[, 1]
Y = bivariateNormEagle[, 2]

weibullNormalEagle <- tibble(horizontal_steps = qweibull(pnorm(X, 0, sqrt(covMatEagle[2,2])),
                                                shape = weibullParameters[1, ][statesForSim],
                                                scale = weibullParameters[2, ][statesForSim]),
                             vertical_steps = Y*normalParameters[2, ][statesForSim]+normalParameters[1, ][statesForSim],state = factor(statesForSim))


```


```{r}
set.seed(1)
rhos <- c(-0.9, -0.45, -0.1, 0.9, 0.45, 0.1)
# rhos<- seq(-0.95, 0.95, length.out = 20)

eagleCorrelation <- list()
cor_vec <- numeric(length(rhos))
for (i in seq_along(rhos)) {
  rho1 <- rhos[i]
  statesForSim <- simNewEagles(obsPerAnimal)
  covMat <- matrix(c(1, rho1, rho1, 1), nrow = 2)
  norm_2d <- MASS::mvrnorm(nrow(eagleData), mu = c(0, 0), Sigma = covMat, empirical = TRUE)
  
  X <- norm_2d[, 1]
  Y <- norm_2d[, 2]
  
weibullNormalEagle <- tibble(horizontal_steps = qweibull(pnorm(X, 0, sqrt(covMatEagle[2,2])),
                                                shape = weibullParameters[1, ][statesForSim],
                                                scale = weibullParameters[2, ][statesForSim]),
                             vertical_steps = Y*normalParameters[2, ][statesForSim]+normalParameters[1, ][statesForSim],state = factor(statesForSim))

  cor_vec[i] <- cor(weibullNormalEagle$horizontal_steps, weibullNormalEagle$vertical_steps)

  p <- ggplot(weibullNormalEagle#tibble(x = weibullNormalEagle$horizontal_steps[eagleData$Segment_ID < 300],
               #      y = weibullNormalEagle$vertical_steps[eagleData$Segment_ID < 300]),
                     ,aes(x = horizontal_steps, y = vertical_steps)) +
    geom_point(alpha = 0.1, color = proj_palette[1]) +
    labs(x = if(rho1>0){expression(bold(Z1))} else{""}, y = if(abs(rho1)==0.9){(expression(bold(Z2)))} else{""}) +
    theme(axis.title = element_text(face = "bold"))


  eagleCorrelation[[as.character(rho1)]] <- ggMarginal(p, fill = proj_palette[2])
}

# Create a data frame with the values
parameter_results <- tibble(rhos, cor_vec)

# Convert the data frame to an xtable object
xtable_table <- xtable(parameter_results, digits = 6)

plot(grid.arrange(grobs = eagleCorrelation, ncol = 3))

ggsave(filename = "correlatedEaglesSim.jpeg", plot = grid.arrange(grobs = eagleCorrelation, ncol = 3),
       path = plotPath)
```

## Now fit the original model to the simulated data
```{r}
statesForSim <- simNewEagles(obsPerAnimal)
rho1 <- 0.2
covMat <- matrix(c(1, rho1, rho1, 1), nrow = 2)
norm_2d <- MASS::mvrnorm(nrow(eagleData), mu = c(0, 0), Sigma = covMat, empirical = TRUE)
  
X <- norm_2d[, 1]
Y <- norm_2d[, 2]
  
weibullNormalEagle <- tibble(horizontal_steps = qweibull(pnorm(X, 0, sqrt(covMatEagle[2,2])),
                                                shape = weibullParameters[1, ][statesForSim],
                                                scale = weibullParameters[2, ][statesForSim]),
                             vertical_steps = Y*normalParameters[2, ][statesForSim]+normalParameters[1, ][statesForSim],state = factor(statesForSim))
prepweibullNormalEagle <- momentuHMM::prepData(data = data.frame(ID = eagleData$Segment_ID,
                                       vertical_steps = weibullNormalEagle$vertical_steps,
                                       horizontal_steps = weibullNormalEagle$horizontal_steps),
                                       coordNames = NULL)

eagleFit2 <- momentuHMM::fitHMM(prepweibullNormalEagle,
                   nbStates = N,
                   dist = list(horizontal_steps = "weibull",
                          vertical_steps = "norm"),
                   Par0 = list(horizontal_steps = c(weibullParameters[1, ], weibullParameters[2, ]),
                          vertical_steps = c(normalParameters[1, ], normalParameters[2, ]))
)

decodedStatesFit2 <- viterbi(m = eagleFit2)

statesForSim %>% table()

pseudoReseagleFit2 <- momentuHMM::pseudoRes(eagleFit2)
```

```{r, include = FALSE}
Rcpp::sourceCpp("/home/anders/Desktop/Skole/Blok 4 - 2023/Project in Statistics/Project-in-Statistics/explorative_environment/manualHMM.cpp")

fit_weibull_normal_hmmFullRcpp <- function(step1, step2, par, Gamma, delta, covarianceMatrix = NULL, eps = 0.001) { 
  objective_function <- function(par){
    mu <- par[1:3]
    sigma <- par[4:6]
    shape <- par[7:9] 
    scale <- par[10:12]
    Gamma <- diag(3) 
    Gamma[!Gamma] <- par[13:18]
    Gamma <- Gamma / rowSums(Gamma)
    delta <- c(par[19], par[20], 1)
    delta <- delta / sum(delta)
    
    lik <- negative_log_likelihood_bivariate_weibull_normal_Rcpp(step1, step2, mu, sigma, shape, scale, Gamma, covarianceMatrix, delta, eps)
    return(lik)
  }
  
  wGamma0 <- Gamma[!diag(3)]
  wDelta0 <- delta[-3] / delta[3]
  par0 <- c(par, wGamma0, wDelta0)
  
  mod <- optim(par0, fn = objective_function, method = "L-BFGS-B",
               lower = c(rep(-Inf, 3), rep(0, 3), rep(0, 6), rep(0, 8)),
               upper = c(rep(Inf, 3), rep(Inf, 3), rep(Inf, 6), rep(1, 8)),
               control = list(maxit = 500))
  
  mu_out <- mod$par[1:3]
  sd_out <- mod$par[4:6] 
  shape_out = mod$par[7:9]
  scale_out = mod$par[10:12]
  Gamma_MLE <- diag(3)
  Gamma_MLE[!Gamma_MLE] <- mod$par[13:18] 
  Gamma_MLE <- Gamma_MLE / apply(Gamma_MLE, 1, sum)
  delta_MLE <- c(mod$par[19], mod$par[20], 1)
  delta_MLE <- delta_MLE / sum(delta_MLE)
  
  return(list(mean_normal = mu_out, sd_normal = sd_out, shape_weibull = shape_out,
              scale_weibull = scale_out, Gamma = Gamma_MLE, delta = delta_MLE,
              message = mod$message, numIter = mod$counts, numEval = NA, value = mod$value,
              convergence = mod$convergence))
}

hiddenStateSequence_weibullnormal <- function(step1, # Values in weibull observations
                                   step2, # Values in normal observations
                                   par, # Concatenation of all parameters
                                   Gamma, #Transition probability matrix
                                   delta, # Initial distribution
                                   independent = TRUE,
                                   covarianceMatrix = NULL,  # Specify if the data is assumed independent in the fitting
                                   eps = 0.001)
{ 
  
  # Function that computes minus the log-likelihood
  viterbi <- function(step1, step2, par) {
    T <- length(step1)
    # Unpack parameters for the first observation vector
    mu <- par[1:3]
    sigma <- par[4:6]
    # Parameter for the Weibull distribution of the second observation vector
    shape <- par[7:9] 
    scale <- par[10:12]
    # S.T.P 
    Gamma <- diag(3) 
    Gamma[!Gamma] <- par[13:18]  # Fill non-diagonal entries
    Gamma <- Gamma / rowSums(Gamma)  # Divide by row sums
    # Initial distribution
    delta <- c(par[19], par[20], 1)
    delta <- delta / sum(delta)
    all_probs <- matrix(1, nrow = T, ncol = 3)  # Probabilities of observations from the first distribution
    for (i in 1:3) {
      if(independent){
        step_prob1 <- dweibull(step1, shape[i], scale[i])  # Probability density function for the second distribution
        step_prob2 <- dnorm(step2, mean = mu[i], sd = sigma[i])  # Probability density function for the second distribution
        all_probs[, i] <- step_prob1*step_prob2
      }
      else{
        all_probs[, i] <- gDensityRcpp(step1, step2, shape[i], scale[i], mu[i], sigma[i], covarianceMatrix, eps)
      }
    }
    v <- delta * all_probs[1, ]
    xi <- matrix(0,nrow=T,ncol=3)
    xi[1,] <- v/sum(v)
    for (t in 2:T) {
      v <- apply(xi[t-1,]*Gamma,2,max)*all_probs[t,]
      xi[t,] <- v/sum(v)
    }
    # most probable state sequence
    stSeq <- rep(NA,T)
    stSeq[T] <- which.max(xi[T,])
    for (t in (T-1):1)
      stSeq[t] <- which.max(Gamma[,stSeq[t+1]]*xi[t,])
    return(stSeq)
  }
  
  # Transform Gamma0 and delta0 to working scale
  wGamma0 <- Gamma[!diag(3)]
  wDelta0 <- delta / delta[3]
  par0 <- c(par,  wGamma0, wDelta0)
  return(viterbi(step1, step2, par0))
}

logAlphaMove <- function(step1,step2,mu,sigma,k, lambda,
                         Gamma,delta, covariancematrix, eps)
{
  nbObs <- length(step1)
  lalpha <- matrix(NA,nbObs,3)
  # probabilities of observations conditional on state
  allProbs <- matrix(1,nrow=nbObs,ncol=3)
  for(state in 1:3) {
    allProbs[, state] <- gDensityRcpp(step1, step2,k[state],lambda[state],
                                      mu[state],sigma[state], covariancematrix, eps)
  }
  lscale <- 0
  v <- delta*allProbs[1,]
  lalpha[1,] <- log(v)
  for(t in 2:nbObs) {
    v <- v%*%Gamma*allProbs[t,]
    lscale <- lscale + log(sum(v))
    v <- v/sum(v)
    lalpha[t,] <- log(v) + lscale
  }
  return(lalpha)
}

pseudoResMove <- function(step1, step2 ,mu, sigma, k, lambda,
                          Gamma,delta , covariancematrix, eps)
{
  nbObs <- length(step1)
  nbStates <- 3
  step1Mat <- matrix(NA,nbObs,nbStates)
  step2Mat <- matrix(NA,nbObs,nbStates)
  step1Res <- rep(NA,nbObs)
  step2Res <- rep(NA,nbObs)
  la <- logAlphaMove(step1,step2,mu,sigma,k,lambda,Gamma,delta, covariancematrix, eps)
  
  for(state in 1:nbStates) {
    for(t in 1:nbObs) {
      # integrate step density function
      step1Mat[t,state] <- pweibull(step1[t],k[state],lambda[state])
      # integrate angle density function
      step2Mat[t,state] <- pnorm(step2[t], mu[state], sigma[state])
    }
  }
  step1Res[1] <- qnorm(delta%*%step1Mat[1,])
  step2Res[1] <- qnorm(delta%*%step2Mat[1,])
  for(t in 2:nbObs) {
    c <- max(la[t-1,]) # cancels out below; prevents numerical errors
    a <- exp(la[t-1,]-c)
    step1Res[t] <- qnorm(t(a)%*%(Gamma/sum(a))%*%step1Mat[t,])
    step2Res[t] <- qnorm(t(a)%*%(Gamma/sum(a))%*%step2Mat[t,])
  }
  return(list(weibullResiduals=step1Res,normalResiduals=step2Res))
}
Gamma0 <- eagleFit1$mle$gamma
delta0 <- eagleFit1$mle$delta[1, ] # Starting parameters for later

```
# Imitated eagle fit
```{r}
correlatedFit <-  fit_weibull_normal_hmmFullRcpp(weibullNormalEagle$horizontal_steps, weibullNormalEagle$vertical_steps,
                               c(normalParameters[1, ], normalParameters[2, ], weibullParameters[1, ], weibullParameters[2, ]), Gamma0, delta0, covarianceMatrix = covMatEagle, 0.001)

correlatedDecodedStates <- hiddenStateSequence_weibullnormal(weibullNormalEagle$horizontal_steps, weibullNormalEagle$vertical_steps, c(correlatedFit$mean_normal, correlatedFit$sd_normal, correlatedFit$shape_weibull, correlatedFit$scale_weibull), Gamma0, delta0, FALSE, covMatEagle, eps = 0.0001)
```

```{r}

pseudoResidualsWeibullNormal <- pseudoResMove(weibullNormalEagle$horizontal_steps, 
                                              weibullNormalEagle$vertical_steps,
                                              correlatedFit$mean_normal,
                                              correlatedFit$sd_normal,
                                              correlatedFit$shape_weibull, 
                                              correlatedFit$scale_weibull,
                                              Gamma0, delta0, covMatEagle, eps = .0001)

# pseudoResidualsWeibullNormal1 <- tibble(weibull = pseudoResidualsWeibullNormal$weibullResiduals) %>% 
#   ggplot(aes(sample = weibull)) + 
#   geom_qq(alpha = .2) + 
#   geom_qq_line(color = "firebrick", linewidth = 1.5) +
#   labs(x = "Theoretical Quantiles (Horizontal steps)", y = "Observed Quantiles") +
#   theme_bw() +
#   theme(text = element_text(size = 12, face = "bold"), 
#         axis.title = element_text(face = "bold", size = 14),
#         plot.title = element_text(hjust = 0.5, size = 16)) 
# 
# # Plot 2
# pseudoResidualsWeibullNormal2 <-  tibble(normal = pseudoResidualsWeibullNormal$normalResiduals) %>% 
#   ggplot(aes(sample = normal)) + 
#   geom_qq(alpha = .2) + 
#   geom_qq_line(color = "firebrick", linewidth = 1.5) +
#   labs(x = "Theoretical Quantiles (Vertical steps)", y = "Observed Quantiles") +
#   theme_bw() +
#   theme(text = element_text(size = 12, face = "bold"), 
#         axis.title = element_text(face = "bold", size = 14),
#         plot.title = element_text(hjust = 0.5, size = 16)) 
# 
# ggsave(filename = "pseudoResidualsWeibullNormal1.jpeg", plot = pseudoResidualsWeibullNormal1, path = plotPath)
# ggsave(filename = "pseudoResidualsWeibullNormal2.jpeg", plot = pseudoResidualsWeibullNormal2, path = plotPath)
# 
# # Specify the quantiles
# quantiles <- c(0.025, 0.25, 0.5, 0.75, 0.975)
# 
# # Calculate the empirical quantiles for weibull residuals
# empirical_weibull <- quantile(pseudoResidualsWeibullNormal$weibullResiduals, probs = quantiles)
# 
# # Calculate the empirical quantiles for normal residuals
# empirical_normal <- quantile(pseudoResidualsWeibullNormal$normalResiduals, probs = quantiles)
# 
# # Calculate the theoretical quantiles of a standard normal distribution
# theoretical <- qnorm(quantiles)
# 
# # Put them into a data frame
# df <- data.frame(
#   Quantile = quantiles,
#   Theoretical = theoretical,
#   Empirical_Weibull = empirical_weibull,
#   Empirical_Normal = empirical_normal
# )
# 
# print(df)
# 
# 
# ####--
# acf_vals <- acf(pseudoResidualsWeibullNormal$weibullResiduals, plot = FALSE)
# acftib <- tibble(ACF = acf_vals$acf, lag = acf_vals$lag)
# acfHorizontalPseudoResiduals1 <- ggplot(acftib[-1,], aes(x = lag, y = ACF)) +
#   geom_hline(yintercept = 0, color = "black", size = 1) +
#   geom_hline(yintercept = c(0.025, -0.025), linetype = "dashed",
#              color = proj_palette[3], linewidth = 1.5) +
#   geom_segment(aes(xend = lag, yend = 0), color = "black", size = 1) +
#   xlab("Lag (Horizontal pseudoresiduals)") +
#   ylab("Autocorrelation") +
#   theme(plot.title = element_text(face = "bold"), 
#         axis.title = element_text(face = "bold"))
# 
# acf_vals1 <-  acf(pseudoResidualsWeibullNormal$normalResiduals, plot = FALSE)
# acftib1 <- tibble(ACF = acf_vals1$acf, lag = acf_vals1$lag)
# acfVerticalPseudoResiduals1 <- ggplot(acftib1[-1,], aes(x = lag, y = ACF)) +
#   geom_hline(yintercept = 0, color = "black", size = 1) +
#   geom_hline(yintercept = c(0.025, -0.025), linetype = "dashed",
#              color = proj_palette[3], linewidth = 1.5) +
#   geom_segment(aes(xend = lag, yend = 0), color = "black", size = 1) +
#   xlab("Lag (Vertical pseudoresiduals)") +
#   ylab("") +  
#   theme(plot.title = element_text(face = "bold"), 
#         axis.title = element_text(face = "bold"))
# 
# ggsave(filename = "acfVerticalPseudoResiduals1.jpeg", plot = acfVerticalPseudoResiduals1,
#        path = plotPath)
# 
# ggsave(filename = "acfHorizontalPseudoResiduals1.jpeg", plot = acfHorizontalPseudoResiduals1,
#        path = plotPath)
```
# Real eagle fit
```{r}
rhoRealEagle <- -0.1 #cor(eagleData$horizontal_steps,eagleData$vertical_steps)

covMatRealEagle <- matrix(c(1,rhoRealEagle, rhoRealEagle, 1), ncol = 2, byrow = T)
realEaglefitWeibullNormal <- fit_weibull_normal_hmmFullRcpp(eagleData$horizontal_steps,
                                                            eagleData$vertical_steps,
                                                            c(eagleFit1$mle$vertical_steps[1, ],
                                                              eagleFit1$mle$vertical_steps[2, ],
                                                              eagleFit1$mle$horizontal_steps[1, ],
                                                              eagleFit1$mle$horizontal_steps[2, ]),
                                                            delta = delta0, Gamma = Gamma0,
                                                            covarianceMatrix = covMatRealEagle, eps = .00001)

correlatedDecodedStates1 <- hiddenStateSequence_weibullnormal(eagleData$horizontal_steps, eagleData$vertical_steps, c(realEaglefitWeibullNormal$mean_normal, realEaglefitWeibullNormal$sd_normal, realEaglefitWeibullNormal$shape_weibull, realEaglefitWeibullNormal$scale_weibull), Gamma0, delta0, FALSE, covMatRealEagle, eps = 0.0001)

eagleData <- eagleData %>% mutate(AltDecodedStates = factor(correlatedDecodedStates1))

pseudoresEagleCorrelated<- pseudoResMove(eagleData$horizontal_steps, 
                                              eagleData$vertical_steps,
                                              realEaglefitWeibullNormal$mean_normal,
                                              realEaglefitWeibullNormal$sd_normal,
                                              realEaglefitWeibullNormal$shape_weibull, 
                                              realEaglefitWeibullNormal$scale_weibull,
                                              Gamma0, delta0, covMatRealEagle, eps = .0001)

```

## Plot marginal weighted after state

```{r}
# numberAfterStateAlt <- correlatedDecodedStates1 %>% tibble(stateNum=.) %>% group_by(stateNum) %>% count() %>% ungroup() %>% mutate(prop = n/sum(n))
# num_observations <- c(numberAfterStateAlt$n[numberAfterStateAlt$stateNum == 1], 
#                       numberAfterStateAlt$n[numberAfterStateAlt$stateNum == 2], 
#                       numberAfterStateAlt$n[numberAfterStateAlt$stateNum == 3])
# 
# # Generate the x values
# x <- density(eagleData$horizontal_steps)$x
# 
# # Calculate the density values for each distribution
# pdf_values <- sapply(1:N, function(i) {
#   density <- dweibull(x, shape = realEaglefitWeibullNormal$shape_weibull[i],
#                       scale = realEaglefitWeibullNormal$scale_weibull[i])
#   density <- density * numberAfterState$prop[numberAfterState$stateNum == i]
#   density
# })
# 
# 
# 
# # Create a data frame for the density values
# df <- data.frame(x = rep(x, (N+1)),
#                  density = as.vector(cbind(pdf_values, rowSums(pdf_values))),
#                  state = factor(rep(c(1:N, "Total"), each = length(x))))
# 
# # Plot the density functions using ggplot2
# xCombinedDensityCorrelated <- ggplot() +
#   geom_histogram(data = eagleData, aes(x = horizontal_steps, after_stat(density)), fill = "steelblue", col = "black", bins = 100, linewidth = 0.5, alpha = .2) +
#   geom_line(data = filter(df, state != "Total"), aes(x = x, y = density, color = state),
#             lwd = 2, alpha = 1.5) +
#   geom_line(data = filter(df, state == "Total"), aes(x = x, y = density),
#           lwd = 1, alpha = 1.5, linetype = "dashed") +
#   xlab("Horizontal steps") +
#   ylab("Density") +
#   scale_color_manual(values = proj_palette,
#                      labels = c("Gliding", "Soaring", "Perching")) +
#   theme(text = element_text(size = 14, face = "bold"),
#         legend.position = "None") +
#   coord_cartesian(xlim = c(0, 2000))
# 
# ggsave("xCombinedDensityCorrelated.jpeg", plot = xCombinedDensityCorrelated, path = plotPath, width = 6, height = 4, units = "in")
```

# Now the vertical steps

```{r}
# Generate the x values
# x <- density(eagleData$vertical_steps)$x
# 
# # Calculate the density values for each distribution
# pdf_values <- sapply(1:N, function(i) {
#   density <- dnorm(x, mean = realEaglefitWeibullNormal$mean_normal[i],
#                       sd = realEaglefitWeibullNormal$sd_normal[i])
#   density <- density * numberAfterState$prop[numberAfterState$stateNum == i]
#   density
# })
# 
# 
# 
# # Create a data frame for the density values
# df <- data.frame(x = rep(x, (N+1)),
#                  density = as.vector(cbind(pdf_values, rowSums(pdf_values))),
#                  state = factor(rep(c(1:N, "Total"), each = length(x))))
# 
# # Plot the density functions using ggplot2
# yCombinedDensityCorrelated <- ggplot() +
#   geom_histogram(data = eagleData, aes(x = vertical_steps, after_stat(density)), fill = "steelblue", col = "black", bins = 200, linewidth = 0.5, alpha = .2) +
#   geom_line(data = filter(df, state != "Total"), aes(x = x, y = density, color = state),
#             lwd = 2, alpha = 1.5) +
#   geom_line(data = filter(df, state == "Total"), aes(x = x, y = density),
#           lwd = 1, alpha = 1.5, linetype = "dashed") +
#   xlab("Vertical steps") +
#   ylab("Density") +
#   scale_color_manual(values = proj_palette,
#                      labels = c("Gliding", "Soaring", "Perching")) +
#   theme(text = element_text(size = 14, face = "bold")) +
#   coord_cartesian(xlim = c(-500, 500))
# 
# ggsave("yCombinedDensityCorrelated.jpeg", plot = yCombinedDensityCorrelated, path = plotPath, width = 6, height = 4, units = "in")
```
## Residual plots

```{r}
# pseudoResRealFitCorrelatedWeibull <- tibble(weibull = pseudoresEagleCorrelated$weibullResiduals[is.finite(pseudoresEagleCorrelated$weibullResiduals)]) %>% 
#   ggplot(aes(sample = weibull)) + 
#   geom_qq(alpha = .2) + 
#   geom_qq_line(color = "firebrick", linewidth = 1.5) +
#   labs(x = "Theoretical Quantiles (Horizontal steps)", y = "Observed Quantiles") +
#   theme_bw() +
#   theme(text = element_text(size = 12, face = "bold"), 
#         axis.title = element_text(face = "bold", size = 14),
#         plot.title = element_text(hjust = 0.5, size = 16))
# 
# ggsave("pseudoResRealFitCorrelatedWeibull.jpeg", plot = pseudoResRealFitCorrelatedWeibull, path = plotPath, width = 6, height = 4, units = "in")

# Plot 2
# pseudoResRealFitCorrelatedNormal <-  tibble(normal = pseudoresEagleCorrelated$normalResiduals[is.finite(pseudoresEagleCorrelated$normalResiduals)])%>% 
#   ggplot(aes(sample = normal)) + 
#   geom_qq(alpha = .2) + 
#   geom_qq_line(color = "firebrick", linewidth = 1.5) +
#   labs(x = "Theoretical Quantiles (Vertical steps)", y = "Observed Quantiles") +
#   theme_bw() +
#   theme(text = element_text(size = 12, face = "bold"), 
#         axis.title = element_text(face = "bold", size = 14),
#         plot.title = element_text(hjust = 0.5, size = 16))
# 
# ggsave("pseudoResRealFitCorrelatedNormal.jpeg", plot = pseudoResRealFitCorrelatedNormal, path = plotPath, width = 6, height = 4, units = "in")
```


```{r}
####--
# acf_vals <- acf(pseudoresEagleCorrelated$weibullResiduals[is.finite(pseudoresEagleCorrelated$weibullResiduals)], plot = FALSE)
# acftib <- tibble(ACF = acf_vals$acf, lag = acf_vals$lag)
# acfHorizontalPseudoResiduals1 <- ggplot(acftib[-1,], aes(x = lag, y = ACF)) +
#   geom_hline(yintercept = 0, color = "black", size = 1) +
#   geom_hline(yintercept = c(0.025, -0.025), linetype = "dashed",
#              color = proj_palette[3], linewidth = 1.5) +
#   geom_segment(aes(xend = lag, yend = 0), color = "black", size = 1) +
#   xlab("Lag (Horizontal pseudoresiduals)") +
#   ylab("") +
#   theme(plot.title = element_text(face = "bold"), 
#         axis.title = element_text(face = "bold"))
# 
# acf_vals1 <-  acf(pseudoresEagleCorrelated$normalResiduals[is.finite(pseudoresEagleCorrelated$normalResiduals)], plot = FALSE)
# acftib1 <- tibble(ACF = acf_vals1$acf, lag = acf_vals1$lag)
# acfVerticalPseudoResiduals1 <- ggplot(acftib1[-1,], aes(x = lag, y = ACF)) +
#   geom_hline(yintercept = 0, color = "black", size = 1) +
#   geom_hline(yintercept = c(0.025, -0.025), linetype = "dashed",
#              color = proj_palette[3], linewidth = 1.5) +
#   geom_segment(aes(xend = lag, yend = 0), color = "black", size = 1) +
#   xlab("Lag (Vertical pseudoresiduals") +
#   ylab("Autocorrelation") +
#   theme(plot.title = element_text(face = "bold"), 
#         axis.title = element_text(face = "bold"))
```

```{r}

# Calculate proportions for decodedstates
decodedstates_prop <- eagleData %>% 
  group_by(Segment_ID, decodedstates) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(Segment_ID) %>%
  mutate(prop_decodedstates = n/sum(n)) %>%
  ungroup() %>%
  dplyr::select(-n) %>%
  pivot_wider(names_from = "decodedstates", values_from = "prop_decodedstates") %>%
  replace_na(list(`1` = 0, `2` = 0, `3` = 0)) %>%
  rename_with(~paste0(., "_decodedstates"), -Segment_ID)

# Calculate proportions for altdecodedstates
altdecodedstates_prop <- eagleData %>% 
  group_by(Segment_ID, AltDecodedStates) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(Segment_ID) %>%
  mutate(prop_altdecodedstates = n/sum(n)) %>%
  ungroup() %>%
  dplyr::select(-n) %>%
  pivot_wider(names_from = "AltDecodedStates", values_from = "prop_altdecodedstates") %>%
  replace_na(list(`1` = 0, `2` = 0, `3` = 0)) %>%
  rename_with(~paste0(., "_AltDecodedStates"), -Segment_ID)

# Join both tables
prop_table <- full_join(decodedstates_prop, altdecodedstates_prop, by = "Segment_ID")

diff_prop_table <- prop_table %>%
  filter(`1_decodedstates` > 0 & `2_decodedstates` > 0 & `3_decodedstates` > 0 &
           `1_AltDecodedStates` > 0 & `2_AltDecodedStates` > 0 & `3_AltDecodedStates` > 0) %>%
  mutate(diff1 = `1_decodedstates` - `1_AltDecodedStates`,
         diff2 = `2_decodedstates` - `2_AltDecodedStates`,
         diff3 = `3_decodedstates` - `3_AltDecodedStates`)
diff_prop_table

```

```{r}
eagleData %>% filter(Segment_ID == "152") %>% ggplot(aes(x = seq_along(Altitude), y = Altitude)) +
  geom_line() + 
  geom_point(aes(col = decodedstates))

eagleData %>% filter(Segment_ID == "152") %>% ggplot(aes(x = seq_along(Altitude), y = Altitude)) +
  geom_line() + 
  geom_point(aes(col = AltDecodedStates))

```

